## 인덱스의 활용

### 인덱스란?

-   인덱스는 Key의 기능만 수행하는 것이 아닌 옵티마이저가 최적의 처리 경로를 결정하기 위한 요소(Factor)이다.
-   인덱스는 아래의 코드로 생성할 수 있다.인덱스의 구조
    -   CREATE \[유니크\] INDEX \[스키마 명\]인덱스명 ON \[스키마명\].테이블명 (컬럼들)  
        대괄호\[\] 항목은 생략 가능합니다.
-   DB 에 저장 되어 있는 데이터는 \[ INDEX-KEY \] , \[ ROW-ID \] 으로 구성되어 있습니다.
-   과도한 인덱스 생성은 SELECT는 빠를 수 있지만 데이터 변경 (INSERT , UPDATE , DELETE ) 시에 느려질 수 있습니다.
-   인덱스 적용 원칙
    -   인덱스 컬럼은 비교되기 전 변형이 일어나면 인덱스를 사용할 수 없습니다.
    -   인덱스 컬럼은 외부적,내부적 변형 둘 다 가능합니다.
    -   부정형 (Not , <>) 조건 시에도 인덱스를 사용하지 않습니다.
    -   인덱스 컬럼은 비교 상수값과 B-Tree 방식으로 문자열(String) 값을 비교하여 찾습니다.
        -   위와 같은 이유로 인해 비교값이 없는 부정형은 인덱스를 사용할 수 있는 방법이 없습니다.
        -   부정형 조건을 긍정형 조건으로 변경하여 인덱스를 사용하는 방법을 권장합니다.
-   인덱스 컬럼의 값이 NULL 이라면 당연히 인덱스 사용이 불가능합니다.
    -   복합적으로 결합된 인덱스 컬럼일 경우 첫번째 컬럼이 아닌 값을 NULL으로 비교할 시에는 인덱스가 사용됩니다.
-   옵티마이저가 필요에 따라 상기 적용원칙을 준수하였음에도 불구하고 특정 인덱스의 사용을 취사 선택함으로 사용되지 않는 인덱스가 생길 수 있습니다.
    -   인덱스의 머지 ( Merge ) 피하기 위해서,
    -   조건의 순위에 차이가 있을 때 취사 선택, 사용자힌트 , 통계정보 등에 의거하여 산출된 엑세스 비용의 차이에 따라 결정될 수 있습니다.

## 외부적 변형

-   함수, 연산자 등에 의해 컬럼에 변형을 가하는 행위
-   SQL함수, 사용자 지정함수 , 연산 , 결합 등으로 가공 시킨 후 비교할 때 발생됩니다.

```
// 예시  

// 인덱스 미사용
SELECT 컬럼1 , 컬럼2 , 컬럼3
    FROM 테이블
WHERE 함수( 컬럼 , 조건 ) = '해당조건'

// 인덱스 사용
SELECT 컬럼1 , 컬럼2 , 컬럼3
    FROM 테이블
WHERE 조건 LIKE '찾을문자열'%
```

외부 함수를 써서 컬럼의 값을 변경 후 조건과 일치하는지 비교하기 때문에 기존의 인덱스를 활용할 수 없습니다.  
하지만 예시로 작성된 LIKE 조건인 경우 기존의 컬럼을 변경하지 않고 조건을 찾기 때문에 인덱스를 활용할 수 있습니다.  
  

#### 정리 : 컬럼의 값을 변경한 후 조건을 찾게 되면 인덱스를 사용할 수 없다.

## 내부적 변형

-   사용자가 의도하여 외부적 변형을 하지 않았음에도 불구하고 서로 다른 데이터 타입을 비교하고자 할 때 DBMS 자체적으로 컬럼의 값을 변경하여 조건을 비교하는 것을 내부적 변형이라고 합니다.
-   변형 기준 참고 (link 넣어야함)// 테이블 생성  
    CREATE TABLE 예제테이블 (
-   `문자, CHAR(10), 숫자, NUMBER(12 , 3), 동적문자, VARCHAR(20), 날짜, DATE )`
-   // 예시

만약 위의 테이블에서 문자 컬럼과 숫자 컬럼을 아래와 같이 비교하려고 합니다,

```
// 비교 예제
SELECT *
    FROM 예제테이블
WHERE 문자 = 10
```

문자 컬럼의 값이 10일 때 라는 조건이 주어졌습니다.  
이 때 DB가 자체적으로 문자를 숫자로 변환하여 값을 비교하게 됩니다.  
위에서 일어난 내부적 변형을 외부적 변형으로 사용하게 된다면 아래와 같습니다.

```
// 비교 예제 외부적 변형
SELECT *
    FROM 예제테이블
WHERE CAST(문자 , SIGNED) // CAST() 는 MYSQL에서 사용하는 타입 변환 함수입니다. SIGNED는 부호가 있는 INTEGER 타입 입니다.
```

인덱스 사용의 핵심은 외부적,내부적으로 조건을 비교하기 전에 컬럼의 값이 변경이 된다면 사용할 수 없다라는 것을 기억하면 됩니다.

#### 추가 : 참고로 컬럼의 값이 NULL 이라면 처리대상에서 제외되므로 사전에 NULL 값을 제외 후 조건을 비교하지 않아도 됩니다.

## 부정형의 비교

-   NOT 조건을 사용하였을 때는 인덱스가 사용되지 않습니다.
-   인덱스는 비교 상수값의 문자열(STRING)과 인덱스 컬럼의 스트링을 B-TREE 방식으로 비교하여 찾게되는데  
    주어진 값이 아닌 값을 검색하기에 비교할 대상이 없습니다.  
    그러므로 인덱스를 사용하기 위해서는 부정형을 긍정형으로 바꾸어 작성하는 방법이 있습니다.
```
	// 예시코드 (인덱스 사용 x)
	SELECT 찾을컬럼
		FROM 테이블1 t1
	LEFT OUTER JOIN (
		SELECT *
			FROM 테이블2 
	) t2 ON t1.아이디 != t2.아이디
	
	// 예시코드 (긍정형 표현으로 인덱스 사용 o )
	SELECT 찾을컬럼
		FROM 테이블1
	WHERE NOT EXISTS(
		SELECT 찾을컬럼
			FROM 테이블2
		WHERE 테이블1.아이디 = 테이블2.아이디
		)
```
- 위의 예시는 테이블1 의 컬럼 아이디와 테이블2의 컬럼 아이디 값이 다른 값들을 가져오는 쿼리입니다. 
	- 조인으로 작성된 쿼리는 != 부정형 사용으로 인덱스를 사용하지 않습니다.
	- NOT EXSITS 또한 NOT 을 포함하고 있기에 부정형이라고 생각할 수 있지만 실제 데이터를 비교하는 서브쿼리 내 WHERE 절에서 긍정형 조건을 사용하여 값들을 비교하였기에 인덱스를 사용할 수 있습니다.

## NULL 을 사용한 비교
- ### NULL 컬럼의 적용
	- 테이블 설계 시 기본값을 NULL 으로 지정하게 된다면 풀스캔을 하거나 다른 조건을 사용해야합니다. 
	```
		// 예시 1 (주문날짜가 NULL 이 아닌 값들을 불러와 주문날짜순 정렬)
		SELECT 주문번호 , 주문날짜 , 주문아이템, 주문수량
			FROM 주문테이블
		WHERE 주문날짜 is NOT NULL
		ORDER BY 주문날짜
		
		// 예시 2 (주문날짜가 '' 이상만 검색)
		SELECT 주문번호 , 주문날짜 , 주문아이템, 주문수량
			FROM 주문테이블
		WHERE 주문날짜 > ''
	```
	- 위의 예시에서 NULL 을 직접적으로 비교 조건으로 사용하기보다는 문자열 비교를 통한 방법으로 변경하여 사용하였습니다.
- 그룹 함수 사용시 인덱스 사용 재고
	- SUM , COUNT , MAX , MIN , AVG 등의 그룹함수 
	- GROUP BY , ORDER BY , UNION , MINUS , INTERSECT 등
	- 위의 명령을 처리하게되면 전체범위 인덱스를 경유함으로써 인덱스 사용시 성능이 낮아질 수 있습니다.

- ### NULL 값 대체 방법
	- 컬럼 기본 값 NULL 대신 '' , 또는 0 등의 '빈 값' 지정합니다

## 분포도에 따른 인덱스 전략
- 아래와 같은 분포도가 있을 때 NULL 값을 활용하여 성능 개선하기
```
	A : 4%;
	B : 6%;
	C : 5%;
	D : 5%;
	E : 80%;
```
- E의 값을 NULL 으로 바꾸어 인덱스 미사용하기
	- NULL 값은 스캔 시 인덱스에 포함되지 않기 때문에 성능이 향상됩니다.

## 옵티마이저 취사선택
- 취사선택
	- `취할 것은 취하고 버릴 것은 버려서 골라 잡는 것을 말한다` 라는 뜻입니다.
-순위에 따른 취사선택
	- 각 컬림이 별도의 인덱스로 생성되어 있다면 인덱스 병합이 일어나지만 조건이 `LIKE` , `BETWEEN` , `<` , `>` 등이 같이 사용되었다면 둘중 하나를 포기합니다.
	
	```
		// 다른 인덱스 사용
		SELECT 가격 , 수량
			FROM 아이템
		WHERE 가격 >= 5000
			AND 수량 >= 100
			
		// 같은 인덱스 사용
		SELECT 가격 , 수량
			FROM 아이템
		WHERE 이름 LIKE '국내산%'
			AND 이름 LIKE '수입산%'
	```
	
- 낮은 처리 비용 선택
	- 옵티마이저는 항상 최저 비용을 엑세스하므로 통계 정보에 따라 사용되는 경우가 다양합니다.
	- 옵티마이저의 목표가 `FIRST_ROWS` 냐 `ALL_ROWS` 냐에 따라 비용 계산 방법이 달라집니다.
	- `FIRST_ROWS` 는 인덱스를 사용하지만 `ALL_ROWS`는 전체 테이블을 스캔합니다.
- 힌트에 의한 선택
	- 기존의 옵티마이저에 정의 되어 있는 인덱스 순위 대신 사용자가 인덱스 순위를 직접 기술하여 사용하는 것을 얘기합니다.
	- 사용 방법은 아래와 같습니다
	```
		// 힌트 사용 방법 : /*+ 힌트() */
		SELECT /*+ INDEX(등록일 인덱스) */ 이름 , 등록일
			FROM 아이템
		WHERE 이름 LIKE `국내산%` 
			AND 등록일 BETWEEN '221123' AND '221224'
	```
	- 위와 같은 SQL 에서는 항상 등록일 인덱스를 사용합니다.
 -힌트 기능 예시
	 - RULE : RULE BASE 옵티마이저를 사용합니다.
	 - FIRST_ROWS : 첫째 레코드의 추출 시간을 최소화 할 목적으로 최적화합니다.
	 - ALL_ROWS : 모든 레코드를 모두 처리하는 시간의 최소화를 목적으로 최적화합니다. 
	 - FULL : 지정된 테이블에 대한 전체스캔
	 - ROWID : 지정된 테이블에 대한 ROWID 에 의한 테이블 스캔
	 - CLUSTER : 지정된 테이블에 대한 클러스터 스캔
	 - HASH : 지정된 테이블에 대한 해시 스캔
	 - INDEX_ASC : 내림차순으로 인덱스를 스캔
	 - INDEX_DESC : 오름차순으로 인덱스를 스캔
	 - AND_EQUALS : 여러개의 인덱스를 병합하여 사용합니다 (2~5개)
	 - ORDERD : FROM 절에 기술된 테이블 순으로 JOIN 합니다.
	 - USE_NL : 먼저 특정 테이블의 ROW 를 엑세스하고 그값에 해당하는 다른 각각의 테이블의 ROW를 찾는 작업을 해당범위까지 실행하는 조인 먼저 각 테이블의 처리범위를 스캔하여 정렬 후 서로 병합하는 조인 방식입니다.
	 - USE_MERGE : 각 테이블의 처리범위를 스캔하여 정렬 후 서로 병합하며 조인합니다.
	 - PARALLEL : 병렬 처리 프로세서의 개수를 지정합니다.
	 - CACHE : 테이블의 로우들을 메모리 내 상주시킵니다.
	 - NOCACHE : 메모리 내 상주 시킨 옵션 해제
	 - MERGE-AJ : 부정형 조인 (안티조인) 을 병합정렬 방식으로 수행합니다.
	 - HASH-AJ : 부정형 조인을 해시 조인 방식으로 수행합니다.
	- 위의 예시들은 오라클 기준의 힌트들이며 사용 DB 힌트들을 참고하여 사용하시면 됩니다.

## 인덱스의 선정
- 인덱스는 실측 자료를 토대로 엑세스의 빈도 , 처리범위의 크기 , 분포도 , 테이블의 크기 , 엑세스 유형등을 종합적으로 검토하여 설정해야합니다.
- 인덱스 대상 테이블 선정
	- 테이블 크기가 작다면 DB가 멀티블럭 I/O 를 수행하기 때문에 성능 차이가 거의 없다.
	- 조인 연결고리가 되는 컬럼의 인덱스가 없을 때는 조인의 방향이 달라질 수 있으며 참조무결성을 지정한 경우 테이블 단위의 LOCK이 발생되므로 조인 연결 컬럼은 인덱스를 생성시키는 것이 좋습니다.
	- 보관용 테이블 , 풀스캔용 테이블 들은 당연히 인덱스를 사용할 필요가 없습니다.
- 분포도와 손익분기점
	- 인덱스를 생성시키려는 컬럼의 `분포도`는 `10~15%` 사이여야 하며 `분포도`란 컬럼이 테이블에 평균적으로 분포되어 있는 정도를 얘기합니다.
	```
	// 분포도 예시
		분포도 = 데이터별 평균 로우수 / 테이블 총 로우수 * 100 = 1 / 컬럼값의 종류 * 100
	```
	- 예를 들면 5개 지점을 가진 회사의 `지점` 컬럼은 값의 종류가 5가지이므로 분포도가 (1/5) * 100 = 20% 가 됩니다. 만약 어떤 테이블의 데이터가 100개를 가지고 있고 GROUP BY 수행 시 평균 10이라고 가정했을 때 (10/100) * 100 = 10% 가 됩니다.
- 인덱스 병합 (Merge)
	- 예시 SQL
	```
		SELECT *
			FROM 테이블
		WHERE 컬럼1 = 'ABC'
			AND 컬럼2 = '123';
	```
	- 위와 같은 SQL을 실행하는 엑세스 경로는 컬럼1 , 컬럼2 인덱스를 병합하여 수행한다고 가정합니다
	- 수행방법은 아래와 같습니다
		1. B-Tree 방법으로 컬럼1 인덱스에서 값이 'ABC'인 첫번째 로우와 컬럼2 인덱스에서 값이 '123' 인 첫번째 로우를 찾습니다. 
		2. 두개의 로우에 있는 ROW ID 를 비교하여 적은 값을 가진쪽 부터 차례대로 스캔하고 ROW ID 값이 같아지면 테이블의 로우를 엑세스하고 ROW ID 가 더 커질 때까지 스캔 후 멈춥니다.
		3. 이후 다른 인덱스에서도 동일하게 반복 수행합니다.
		4. 위와 같은 반복 수행 도중 다음 로우 값이 조건값과 다르면 작업을 중단합니다.
	- 위의 경우에서 인덱스 병합을 통해 테이블 엑세스 양은 줄이게 되었으나 인덱스 간 병합 양이 늘었으므로 실제 수행양이 줄었는지에 대해서도 고려해보아야 합니다.
	- 인덱스 병합을 하지 않고 컬럼1의 인덱스만 사용하는 예시
		1. B-Tree 방법으로 컬럼1 인덱스에서 값이 'ABC'인 첫번째 로우를 찾습니다.
		2. 인덱스 로우에 있는 ROW_ID 정보를 이용하여 테이블 로우를 엑세스합니다.
		3. 테이블 로우에 있는 컬럼2의 값이 '123'인 값만 선택합니다.
		4. 컬럼1의 인덱스를 로우 값이 조건과 다를 때까지 반복 수행합니다.
	- 정리
		- 인덱스 병합의 경우 서로 다른 몇개의 인덱스를 같은 ROW ID으로 병합하여야 하므로 실제 일한 양과 머지에 성공한 양에는 차이가 발생할 수 있습니다.
		
- 결합 인덱스 
	- 결합 인덱스를 쓰는 이유
		- where 조건에서 and 조건으로 자주 결합되어 사용되면서
		각각의 분포도 보다 두개 이상의 컬럼이 결합될 때 분포도가 좋아지는 컬럼들
		- 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼들
		- order by 에서 자주 사용되는 컬럼들
		- 하나 이상의 키 컬럼 조건으로 같은테이블의 컬럼들이 자주 조회될 때
	- 결합 인덱스 테이블 고려해야 할 우선순위
		- 조건절에서 인덱스의 첫번째 컬럼을 사용하지 않으면 인덱스는 사용되지 않습니다.
		- where절 조건에서 많이 사용되는 컬럼 우선시
		- Eqaul ('=') 으로 사용되는 컬럼 우선
		- 분포도가 좋은 컬럼을 우선
		- 자주 이용되는 순서대로 결합 인덱스 컬럼의 순서 결정

	<br/>

	- 예시 ( 컬럼1 + 컬럼2 인덱스가 있다고 가정)

	```
		SELECT *
			FROM 테이블
		WHERE 컬럼1 = 'A'
			AND 컬럼2 = '115'
	```
	- 예시 설명
		```

		- 예시 1 ( 작업 순서 컬럼1 - 분포도 넓음 , 컬럼2 - 분포도 좁음 )
			1. B-Tree 방식으로 컬럼1 = 'A' 이고 컬럼2 = '115' 인 첫번째 로우를 찾습니다.
			2. ROW ID 를 이용하여 테이블 로우를 엑세스합니다.
			3. 다음 로우를 차례대로 스캔하며 조건을 비교하여 조건 만족 시 테이블 로우를 엑세스 하고 아닐 시 작업을 종료합니다.
		- 예시 2 ( 작업 순서 컬럼2 - 분포도 좁음 , 컬럼1 - 분포도 넓음 )
			1. B-Tree 방식으로 컬럼2 = '115' 이고 컬럼1 = 'A' 인 첫번째 로우를 찾습니다.
			2. ROW ID 를 이용하여 테이블 로우를 엑세스합니다.
			3. 다음 로우를 차례대로 스캔하며 조건을 비교하여 조건 만족 시 
			테이블 로우를 엑세스 하고 아닐 시 작업을 종료합니다.
		```
	- 위의 두가지 예시는 같은 조건을 사용하지만 쿼리 수행 방법이 다릅니다.
		- 두 조건 모두 eqaul ('=') 을 사용한 경우에는 수행량 차이가 없습니다.
		- 분포도 보다 중요한 요소는 eqaul ('=') 조건이 먼저 사용될 것인지 입니다.
		- `LIKE` , `BETWEEN` , `>` , `<` 등과 같은 조건이 사용될 시에는 수행속도에 영향을 줍니다.
		- 결합 인덱스에서는 앞선 컬럼이 eqaul ('=') 으로 사용되지 않으면 그 뒤 
		컬럼을 eqaul ('=') 으로 사용했더라도 처리할 범위가 줄어들지 않습니다.
	
	<BR/>

	- 예시 SQL
	```
		SELECT * FROM 테이블 WHERE 컬럼1 = 'A' WHERE 컬럼2 BETWEEN '113' AND '115'
	```
	- SQL 작업 설명
	```
		예시 1 ( 분포도가 좁은 컬럼1이 앞에 위치하고 컬럼2가 결합 인덱스로 생성되어 있는 경우 )

		1. B-Tree 방식으로 컬럼1 = 'A' 이고 컬럼2 = '111' 인 첫번째 로우를 찾습니다.
		2. ROW ID 를 이용하여 테이블의 로우를 엑세스합니다.
		3. 다음 로우를 차례대로 스캔하면서 컬럼1이 'A' 가 아니거나 컬럼2가 '113'보다 클떄까지 테이블 로우를 엑세스하고 그렇지 않으면 작업을 종료합니다.

		예시 2 (컬럼1이 '='로 사용된 경우)
		
		1. B-Tree 방식으로 컬럼2 = '111' 이고 컬럼1 = 'A' 인 첫번째 로우를 찾습니다.
		2. ROW ID 를 이용하여 테이블 로우를 엑세스합니다.
		3. 다음 로우를 차례대로 스캔하면서 조건을 만족할 때까지 계속합니다.
		4. 조건을 만족하면 테이블의 로우를 엑세스합니다.
		5. 다음 로우를 계속 스캔하면서 3~4 를 반복합니다.
		6. 컬럼2의 조건을 더 이상 만족하지 않으면 작업을 종료합니다.
	```
	- 예시 1
		- 인덱스의 첫번째 컬럼이 '=' 으로 사용되었으므로 컬럼2가 '111'과
		'113' 사이에 있는 로우만 엑세스할 수 있습니다.
		- 컬럼1으로 정렬된 후 다시 컬럼2가 정렬되어 있으므로 컬럼1이 '=' 으로 사용된 범위 내엔 컬럼2가 차례대로 정렬되어 있으므로 '113' 뒤에는 '113' 보다 적은 값이 없기 때문입니다.
		- 그러므로 '113' 이상의 값을 만날 때 작업을 종료합니다.
	- 예시 2
		- 인덱스의 첫번째 컬럼이 '=' 으로 사용되지 않았을 때 뒤에 있는 컬럼을 '=' 으로 사용했다고 하더라도 처리범위는 줄어들지 않습니다.
		- '=' 조건은 단지 테이블을 엑세스 할 것인지에 대한 판단만 수행합니다.
		- 컬럼2 가 문자 타입이기 때문에 `111A` 가 있을 수 있으며 숫자 타입이라면
		`111.01` 도 있을 수 있습니다.
		- 상기 이유 때문에 컬럼 `111` 과 `113` 사이의 값을 모두 확인해보아야 합니다. ( 이러한 문제도 해결방법이 있다고 합니다. - 뒤에서 학습 -)

	- 정리 
		- BETWEEN 조건을 IN 절으로 대체하여 사용 
		- IN 절은 
			Where 컬럼1 = '조건' OR 컬럼2 = '조건' 과 같이 쓰입니다.
		- 분포도가 좋은 인덱스의 조건이 '=' 으로 사용되어 데이터를 읽어들입니다.
		- 인덱스 생성이 (컬럼1,컬럼2,컬럼3) 으로 되어 있을 때 필요한 조건이 2가지라고 하더라도 3가지 조건을 '=' 으로 주었을 때 인덱스를 사용하여 성능을 향상시킬 수 있습니다.

<br/>


- 결합 인덱스 컬럼 순서 결정 시 주의점
	- 결합 인덱스 사용 빈도
		- 결합 인덱스의 첫번째 컬럼을 조건에서 사용하지 않으면 인덱스는 사용되지 않습니다.
	- 항상 '=' 으로 사용되는지 여부
		- 앞선 조건의 컬럼이 '=' 으로 사용되지 않는다면 뒤에 있는 컬럼이 '=' 으로 사용되었더라도 처리 범위가 줄어들지 않습니다
	- 분포도가 좋은 컬럼을 우선
		- 분포도가 좋은 (좁은) 컬럼을 우선 사용하여야 처리범위를 보다 빠르게 줄일 수 있습니다.
		- 향후 `LIKE` , `BETWEEN` , `<` , `>` 과 같은 조건을 사용하여 처리 범위가 늘어난 경우 대비하기 유리합니다.
	- 자주 사용되는 정렬 순서
		- 인덱스의 컬럼 순서와 수행하고잫 ㅏ는 정렬 순서가 일치한다면 굳이 정렬 시키지 않고도 원하는 결과를 추출할 수 있습니다.
		- 부분범위처리를 이용하여 속도향상을 얻을 수 있습니다.
	- 상기 4가지 기준을 토대로 첫번째 컬럼을 선정합니다.

<br/>


- 결합인덱스의 컬럼순서 결정 방법
	- 항상 사용되는지 
	- 항상 '=' 으로 사용되는지
	- 분포도가 좋은 컬럼을 우선 
	- 자주 사용되는 정렬 순서 우선
	- 성능향상을 위한 추가 컬럼 탐색
	- 손익 분기점 이하의 컬럼 인덱스 생성
	- 부분범위처리 위해 손익분기점 이상의 분포도 컬럼 인덱스 생성
	
<br/>


- 인덱스 선정 절차
	- 해당 테이블의 가능한 모든 엑세스 형태 수집
		- 반복 수행되는 엑세스 형태 찾기
			- 반복수행되는 엑세스는 `자신의 수행속도 * 반복횟수` 만큼의 부하를 가집니다
			- 이러한 엑세스 유형을 찾기 위해 `다른 테이블`과 `조인` 시 연결고리가 되는 `기본키` 또는 `외부키`를 찾아 검토합니다
			- `서브쿼리`으로 적용되는 경우 `페치` 후 `루프` 내에서 반복 수행되는 경우를 예상해 연결고리 컬럼 찾아 검토합니다.
		- 분포도가 양호한 컬럼 발췌하여 엑세스 유형 조사
			- 하나의 컬럼만으로도 충분한 수행속도를 보장받을 수 있는 커럶 찾기
		- 자주 넓은 범위의 조건이 사용되는 경우 찾기
			- 부분범위 처리
				- 작업 수행중 추출할 로우수가 운반 단위에 도달하면 수행을 멈춥니다.
				# 계속 쓰기
		- 조건에 자주 사용되는 주요 컬럼 추출하여 엑세스 유형 조사
		- 자주 결합되어 사용되는 컬럼들의 조합 형태 및 정렬 순서 조사
		- 역순으로 정렬하여 추출되는 경우 조사
		- 일련번호 부여하는 경우 조사
		- 통계자료 추출을 위한 엑세스 유형 조사
	- 대상 컬럼 선정 및 분포도 조사
	- 반복 수행되는 엑세스 경로 해결
	- 클러스터링 검토
	- 인덱스 컬럼의 조합 및 순서 결정
	- 시험 생성 및 테스트
	- 수정 / 적용

<br/>

---
# 조인

## 조인 최적화
- 가장 효율적인 논리적 조인 경로는 이미 정해져 있습니다.
- 최적의 경로를 찾을 수 있도록 인덱스,클러스터 등의 옵티마이징 펙터를 지정해주어야 합니다.

## 조인 순서
- 조인 순서
- 조인은 각 집합의 처리범위와 순서에 따라 영향을 받습니다.
- 좁은 범위부터 처리할 경우 효율이 증가합니다.
- 하지만 모든 조인이 순서에 영향을 받는것은 아닙니다.

## 조인 유형 
- 중첩 루프 조인 ( Nested Loop Join )
	- 수행속도
		- 조인의 순서에 따라 수행속도 차이가 많이 납니다.
	- 조인 성공률
		- 조인 성공률이란?
			- 조인 조건을 만족하는 총 로우 (성공 로우) 수
			- 즉 조인 성공률이 낮을수록 이후 처리범위가 줄어듭니다.
	- 연결고리 상태
		- 정상
			- 테이블 간 값들이 모두 존재하고 인덱스가 있을 때
				- 처리범위를 줄여나가며 성능 향상
		- 이상 
			- 어느 한쪽의 연결고리에 인덱스(혹은 클러스터)가 없을 때
				- 테이블1의 값이 테이블2에 존재하지 않을 떄
				테이블1의 로우 수만큼 테이블2를 풀스캔하는 최악의 경우가 발생합니다.
				- 해당 경우 인덱스가 없는 테이블에서
				인덱스가 있는 테이블으로 엑세스할 수 있도록 설계해야합니다.
			- 이상 상태들
				- 조인되는 컬럼이 1대1으로 대응되지 않는 경우
				- 데이터 타입 차이에 의해 발생되는 경우
		
- 병합 정렬 조인 ( Sort Merge Join )
	- 연결고리 인덱스 사용 x
	- 연결고리에 영향을 받지 않습니다.
	- 양쪽 연결고리 이상 시 병합 정렬 조인

<br/>

## 조인의 튜닝
- 튜닝 시 고려사항
	1. 중첩 반복 (Nested Loop) 조인이 유리한지 병합 정렬 (Sort Merge) 조인이 유리한지 판단
	2. 연결고리의 상태 확인 후 문제점 파악 후 인덱스 추가여부 결정
	3. 연결고리를 제외한 컬럼들의 조건에 사용된 연산자와 인덱스 상태를 비교하여 처리범위를 가장 많이 줄여주는 조건을 찾습니다.
	4. 현재 인데스가 현재 찾은 최소 범위를 엑세스할 수 있도록 구성되어 있는지 확인합니다. 그렇지 못하다면 그 다음 순서의 최소 범위를 찾습니다.
	5. 부분범위처리가 가능한지 탐색합니다. 부분처리범위의 경우 처리범위가 넓더라도 수행속도를 보장할 수 있기 때문입니다.
	
- 조인과 반복연결 (Loop Query)
	- 반복 연결
		- 기준 테이블 처리범위에 있는 로우들을 차례로 읽어 그 상수값으로 연결해야 할 다른 테이블을 찾는 방법
	- 전체범위처리방식
		- 조인
			- 테이블1과 테이블2를 조인할 때 , 그리고 테이블1의 로우의 범위가 1000건이라면 1000번의 연결작업이 랜덤 엑세스 방식으로 수행됩니다.
			- 연결 된 로우들은 수행시킨 SQL에 따라 추가적인 2차 가공을 한 후 운반단위만큼 추출합니다.
			- 그러나 1000번의 연결을 위해 단 한번의 SQL이 실행되었습니다.
		- 반복연결
			- 테이블 1과 테이블2를 반복연결 할 때 , 그리고 테이블 1의 로우 범위가 1000건이라면 각 로우에 대해 대응되는 테이블 2의 로우들을 랜덤으로 엑세스합니다.
			- 그러나 각각의 연결작업마다 별도의 SQL이 수행되어
			연결 작업에만 1000번의 SQL이 실행됩니다.
			- 총 1001번의 SQL이 실행됩니다
	- 부분처리방식
		- 부분처리방식에서는 처리범위가 넓더라도 운반단위가 채워질 때까지만 연결작업이 일어납니다.
		- 조인은 SQL이 한번 실행되지만 반복연결방식은 `운반단위 +1`번의 SQL이 수행됩니다.
	- 비교
		- 전체범위처리가 된 이유가 연결되는 모든테이블에 원인이 있다면 조인이 효과적입니다.
		- 연결되는 테이블 중 하나를 부분범위처리로 바꿀 수 있다면 반복연결방식이 효과적입니다.
		- SQL이 부분범위처리가 된다면 조인이 효과적입니다.	

<br/>

- 중첩 반복 (Nested Loop) 조인 과 병합정렬(Sort Merge) 조인
	- 중첩 반복 조인
		- 어떤 테이블의 처리범위를 하나씩 엑세스하며 그 추출된 값으로 연결한 테이블을 조인하는 방식
		- 특징
			- 순차적
				- 테이블과 각각의 로우들이 순차적으로 처리됩니다.
			- 선행적
				- 먼저 엑세스되는 테이블의 처리범위에 의해 처리량이 결정됩니다.
			- 종속적
				- 나중에 처리되는 테이블은 앞서 처리된 값을 받아 엑세스 됩니다.
			- 랜덤엑세스
				- 주로 랜덤엑세스 방식으로 처리됩니다. 
				- 선행 테이블의 인덱스 엑세스 첫번째 로우는 랜덤엑세스 방식이며 나머지 로우는 스캔합니다.
				- 연결작업은 모두 랜덤엑세스로 진행됩니다.
			- 선택적
				- 주어진 조건에 있는 모든 컬럼들이 인덱스를 가지고 있더라도 모두가 사용되는 것은 아닙니다 
			- 연결고리 상태 , 방향성
				- 연결고리가 되는 인덱스에 의해 연결작업이 수행되므로 연결고리 상태가 매우 중요합니다.
			- 부분범위처리 가능
				- 연결작업 수행 후 마지막으로 CHECK 되는 조건은 부분범위처리를 하는 경우에는 조건의 범위가 넓을수록  아예 없다면 오히려 빨라집니다. 
		- 사용기준
			1. 부분범위처리를 하는 경우 유리합니다.
			2. 조인되는 어느 한쪽이 상대방 테이블에서 추출된 결과를 받아야 처리범위를 줄일 수 있는 상태라면 항상 유리합니다.
			3. 주로 처리량이 적은 경우에 유리해집니다. 그것은 처리방식이 주로 랜덤 엑세스 방식이므로 많은 양의 랜덤 엑세스가 발생한다면 수행속도가 당연히 나빠지기 때문입니다.
			4. 가능한 한 연결고리 이상 상태를 만들지 않도록 주의합니다.
			5. 순차적으로 처리되기 때문에 어떤 테이블이 먼저 엑세스 되느냐에 따라 수행속도에 영향을 미치므로 최적의 엑세스 순서가 되도록 적절한 조치를 해야합니다.
			6. 부분범위처리를 하는 경우에는 운반단위의 크기가 수행속도에 많은 영향을 미칠 수 있습니다. 운반단위가 적을수록 빨리 운반단위를 채울 수 있으나 페치 횟수에서는 불리해지는 이중성을 가지고 있습니다.
			7. 선행 테이블의 처리 범위가 많거나 연결테이블의 랜덤 엑세스 양이 아주 많다면 병합 정렬 조인보다 불리해지는 경우가 많습니다.

	- 병합정렬 조인
		- 양쪽 테이블의 처리범위를 각자 엑세스하여 정렬한 결과를 차례로 스캔하며 연결고리의 조건으로 병합해 가는 방식입니다.
		- 특징
			- 동시성
				- 동시적으로 처리됩니다. 테이블 각자가 자신의 처리범위를 엑세스하여 정렬해 둡니다.
			- 독립적
				- 각 테이블은 다른 테이블에서 어떠한 상수값도 제공받지 않습니다. 자신에게 주어진 상수값에 의해서만 범위를 줄입니다.
			- 전체범위처리
				- 결고 부분범위처리를 할 수 없으며 항상 전체범위처리를 합니다.
			- 선택적
				- 주어진 조건에 있는 모든 컬럼들이 인덱스를 가지고 있다고 하더라도 모두가 사용되지는 않습니다. 
				- 연결고리가 되는 컬럼은 인덱스를 전혀 사용하지 않습니다.
			- 무방향성
				- 조인의 방향과는 전혀 무관합니다.
			- 중첩반복조인과 비교사항
				- 스스로 자신의 처리범위를 줄이기 위해 사용되는 인덱스는 대개 가장 유리한 한가지만 사용됩니다.
				- 그 외 조건들은 비록 인덱스를 사용하지 못한다 하더라도 병합할 작업 대상을 줄여 주기 때문에 중요한 의미를 가집니다.
		- 사용기준
			1. 전체범위처리를 하는 경우에 주로 유리합니다.
			2. 상대방 테이블에서 어떤 상수값을 받지 않고도 처리범위를 줄일 수 있는 상태인 경우 유리합니다.
				- 중첩반복조인한 범위의 크기와 병합정렬 조인한 범위의 크기를 대비해보아 상수값을 받아 줄어진 범위가 약 30% 이상이라면 병합정렬조인이 유리해집니다.
				- 부분범위처리 경우라면 처리할 전체범위가 아닌 첫번째 운반단위에 도달하기 위해 엑세스하는 범위에 대해서 판단해야합니다.
			3. 주로 처리량이 많은 경우에 유리합니다.
			4. 연결고리 이상 상태에 영향을 받지않으므로 연결고리를 위한 인덱스를 생성할 필요가 없을 때 유용합니다.
			5. 스스로 자신의 처리범위를 어떻게 줄일 수 있느냐가 수행속도에 많은 영향을 미치므로 효율적으로 엑세스할 수 있는 인덱스가 필요합니다.
			6. 전체범위처리를 하므로 운반단위의 크기가 수행속도에 영향을 미치지않습니다. 가능한 운반단위를 크게하는 것이 페치 횟수를 줄여줍니다.
			7. 처리할 데이터량이 적은 어플에서는 중첩반복 조인이 유리하기 때문에 함부로 병합정렬조인을 사용하지 말아야합니다.
			8. 옵티마이저 목표가 모든 로우일 경우 병합정렬조인으로 실행계획이 수립되므로 부분범위 처리를 하고자 한다면 옵티마이저 목표를 확인해야합니다.
	
<br/>

## 클러스터링

- 클러스터의 구조 및 특징
	- 클러스터는 테이블이나 인덱스처럼 저장공간을 가지고 있는 하나의 오브젝트입니다.
	- 클러스터는 테이블의 상위개념으로 클러스터 인덱스를 가지고 있습니다.
	- 클러스터 인덱스란 컬럼을 기준으로 하나씩 인덱스 로우를 가집니다.
	- 클러스터링은 단일 테이블 클러스터링, 다중 테이블 클러스터링으로 나뉩니다.
- 단일 클러스터링
	- 특징
		- 지정된 클러스터에 하나의 테이블만 생성시키는것입니다.
		- 주로 넓은 범위의 데이터를 동시에 엑세스할 때 사용됩니다.
	- 인덱스와 비교
		- 인덱스는 조건과 일치하는 컬럼의 값의 ROWID 를 통해 로우를 찾습니다.
		- 첫번째 로우는 스캔방식으로 처리되지만 나머지 로우들은 랜덤 엑세스 방식으로 처리됩니다.
		- 클러스터는 B-Tree 형식으로 클러스터 헤더 정보를 찾아 조건과 일치하는 결과 값들을 스캔방식으로 엑세스합니다.
	- 비고
		- 클러스터는 분포도가 넓을 때 사용하여야 효과적입니다.
		- 많은 양의 랜덤엑세스가 발생하는 인덱스의 단점을 보완해줄 수 있습니다.
- 다중 클러스터링
	- 특징
		- 지정된 클러스터에 두개 이상의 테이블을 생성시키는 것입니다.
		- 같은 클러스터값을 가진 각 테이블의 로우는 정해진 장소에 같이 저장되므로 여러테이블을 조인하는속도를 향상시키고자 할 떄 주로 사용합니다.
		- 정규화 작업에 의해 어쩔 수 없이 분할된 테이블들의 연결을 빠르게하기 위해 사용됩니다.
		- 
- 클러스터컬럼의 선정
	- 클러스터링의 부하
		- 클러스터는 검색 효율만 높여줄뿐이며 입력,수정,삭제시에는 추가적인 부하가 발생됩니다.
		- 입력
			- 기존 테이블
				- 입력 시점에 프리 리스트에서 할당받은 저장공간에 무조건 저장합니다.
				- 저장하고 있는 블럭이 PCTFREE (Block 공간 설정) 에 도달하면 새로운 프리 리스트를 요구합니다.
			- 클러스터링 테이블
				- 로우들에 따라 저장위치가 달라지므로 프리리스트를 요구하는 횟수가 증가합니다.
				- 트랜잭션의 빈도나 처리 시간대를 감안하여 사용해야 합니다.
		- 수정
			- 클러스터링 테이블
				- 부하
					- 클러스터 컬럼 수정
						- 컬럼값이 변한다는 내용은 추가적인 클러스터 체인 블럭이 발생합니다.
					- 그외 컬럼 수정
				- 비고
					- 잦은 수정이 일어나는 컬럼은 클러스터 컬럼으로 지정하는것은 안좋습니다.
		- 삭제
			- Delete
				- 로우를 삭제할 때는 부하가 일어나지 않습니다.
				- 오히려 클러스터링을 함으로써 인덱스의 개수가 줄어들었다면 오히려 성능이 좋을 수 있습니다.
			- Drop
				- 테이블을 Drop 할 때는 DDL (데이터 정의 언어) 가 실행되므로 롤백 (Rollback) 할 수 없습니다.
				- 그러나 클러스터링 테이블을 삭제시키면 내부적으로 DELETE 명령어가 실행되어 롤백 세그먼트를 할당받아 데이터를 저장하게 되어 많은 부하가 일어나게됩니다.
				- 해결방안
					1.
						- 삭제할 내용을 충분히 담을 수 있는 큰 롤백 세그먼트를 가지고 있어야합니다.
						- 작업 다음과 같은 명령어로 지정해야합니다.
							```
							// 오라클 기준
							SET TRANSACTION USE ROLLBACK SEGMENT large_rollback_segment_name;
							```  				
						- 만약 지금까지 어떤 작업을 실행중이었다면 다음과 같은 에러메세지가 나타납니다.
							```
							// 오라클 기준
							ORA-01453:SET TRANSACTION must be first statement of transaction.
							```
						- 그 이유는 이미 어떤 트랜잭션이 시작하여 종료되지 않은 상태이므로 이미 어떤 롤백 세그먼트가 지정되어 있기 때문입니다. 
						- 이런 경우 커밋이나 롤백 명령을 사용하여 사용중인 트랜잭션을 종료한 후 수행시켜야합니다. 
					2. 
						- 만약 충분히 큰 롤백 세그먼트를 가지고 있지 않을 때
							- 분할하여 로우를 삭제시킨 후 테이블을 삭제시켜야합니다.
	- 클러스터의 선정 절차
		- 6블럭 이상의 테이블 중에서 선택합니다
			- 그 이하는 굳이 클러스터링을 하지않아도 되기 때문입니다.
		- 다량의 범위를 빈번하게 엑세스하는 경우
			- 클러스터링을 이용한다면 넓은 범위의 엑세스를 자주 사용할 때 집계 테이블을 만들지 않고도 해결할 수 있습니다.
			- 특히 `LIKE` 나 `BETWEEN` 등을 자주 사용하는 경우에 항상 `=`으로 사용된다면 적절한 결합인덱스로도 충분히 해결할 수 있습니다.
		- 클러스터 컬럼의 효율성 판단
			- 분포도가 좋다면 인덱스만으로도 해결이 가능합니다.
			- 분포도가 너무 넓으면 효율이 나빠질 수 있습니다.
			- 클러스터에 저장되는 로우가 많다면 클러스터 체인이 많이발생하게 되고 적은 로우를 가진다면 저장공간을 낭비하게 됩니다.
		- 수행속도 테스트
			- 클러스터링을 사용하여 테스트 시 수행속도가 기대 이하라면 별도의 집계 테이블을 사용해야합니다.
	- 클러스터링 형태 판단기준
		- 단일테이블 클러스터링
			- 넓은 범위의 처리를 스캔방식으로 유도
		- 다중테이블 클러스터링
			- 여러가지 테이블의 조인 향상
	- 클러스터링 테이블 체인
		- 일반테이블
			- 저장된 로우의 길이가 늘어나는 것을 대비하기 위해 `PCTFREE` 라는 파라메터로 여유공간을 지정합니다.
			- 만약 증가한 길이가 여유공간보다 많다면 체인이 발생됩니다.
		- 클러스터링 테이블
			- 새로운 로우가 추가되었을 때 사이즈를 초과하게 된다면 체인이 발생합니다.
			- 체인 블럭은 클러스터 키 컬럼에 따라 부여받으며 같은 키값을 가진 로우들은 같은 체인블럭에 저장됩니다.
	- 클러스터링 사이즈
		- 

<br/>


# 참고 자료
- 대용량 데이터베이스 솔루션 I 

---
## 참고 예정
- 대용량 데이터베이스 솔루션 II
- Real MySQL 8.0 1권
- Real MySQL 8.0 2권