## 인덱스의 활용

### 인덱스란?

-   인덱스는 Key의 기능만 수행하는 것이 아닌 옵티마이저가 최적의 처리 경로를 결정하기 위한 요소(Factor)이다.
-   인덱스는 아래의 코드로 생성할 수 있다.인덱스의 구조
    -   CREATE \[유니크\] INDEX \[스키마 명\]인덱스명 ON \[스키마명\].테이블명 (컬럼들)  
        대괄호\[\] 항목은 생략 가능합니다.
-   DB 에 저장 되어 있는 데이터는 \[ INDEX-KEY \] , \[ ROW-ID \] 으로 구성되어 있습니다.
-   과도한 인덱스 생성은 SELECT는 빠를 수 있지만 데이터 변경 (INSERT , UPDATE , DELETE ) 시에 느려질 수 있습니다.
-   인덱스 적용 원칙
    -   인덱스 컬럼은 비교되기 전 변형이 일어나면 인덱스를 사용할 수 없습니다.
    -   인덱스 컬럼은 외부적,내부적 변형 둘 다 가능합니다.
    -   부정형 (Not , <>) 조건 시에도 인덱스를 사용하지 않습니다.
    -   인덱스 컬럼은 비교 상수값과 B-Tree 방식으로 문자열(String) 값을 비교하여 찾습니다.
        -   위와 같은 이유로 인해 비교값이 없는 부정형은 인덱스를 사용할 수 있는 방법이 없습니다.
        -   부정형 조건을 긍정형 조건으로 변경하여 인덱스를 사용하는 방법을 권장합니다.
-   인덱스 컬럼의 값이 NULL 이라면 당연히 인덱스 사용이 불가능합니다.
    -   복합적으로 결합된 인덱스 컬럼일 경우 첫번째 컬럼이 아닌 값을 NULL으로 비교할 시에는 인덱스가 사용됩니다.
-   옵티마이저가 필요에 따라 상기 적용원칙을 준수하였음에도 불구하고 특정 인덱스의 사용을 취사 선택함으로 사용되지 않는 인덱스가 생길 수 있습니다.
    -   인덱스의 머지 ( Merge ) 피하기 위해서,
    -   조건의 순위에 차이가 있을 때 취사 선택, 사용자힌트 , 통계정보 등에 의거하여 산출된 엑세스 비용의 차이에 따라 결정될 수 있습니다.

## 외부적 변형

-   함수, 연산자 등에 의해 컬럼에 변형을 가하는 행위
-   SQL함수, 사용자 지정함수 , 연산 , 결합 등으로 가공 시킨 후 비교할 때 발생됩니다.

```
// 예시  

// 인덱스 미사용
SELECT 컬럼1 , 컬럼2 , 컬럼3
    FROM 테이블
WHERE 함수( 컬럼 , 조건 ) = '해당조건'

// 인덱스 사용
SELECT 컬럼1 , 컬럼2 , 컬럼3
    FROM 테이블
WHERE 조건 LIKE '찾을문자열'%
```

외부 함수를 써서 컬럼의 값을 변경 후 조건과 일치하는지 비교하기 때문에 기존의 인덱스를 활용할 수 없습니다.  
하지만 예시로 작성된 LIKE 조건인 경우 기존의 컬럼을 변경하지 않고 조건을 찾기 때문에 인덱스를 활용할 수 있습니다.  
  

#### 정리 : 컬럼의 값을 변경한 후 조건을 찾게 되면 인덱스를 사용할 수 없다.

## 내부적 변형

-   사용자가 의도하여 외부적 변형을 하지 않았음에도 불구하고 서로 다른 데이터 타입을 비교하고자 할 때 DBMS 자체적으로 컬럼의 값을 변경하여 조건을 비교하는 것을 내부적 변형이라고 합니다.
-   변형 기준 참고 (link 넣어야함)// 테이블 생성  
    CREATE TABLE 예제테이블 (
-   `문자, CHAR(10), 숫자, NUMBER(12 , 3), 동적문자, VARCHAR(20), 날짜, DATE )`
-   // 예시

만약 위의 테이블에서 문자 컬럼과 숫자 컬럼을 아래와 같이 비교하려고 합니다,

```
// 비교 예제
SELECT *
    FROM 예제테이블
WHERE 문자 = 10
```

문자 컬럼의 값이 10일 때 라는 조건이 주어졌습니다.  
이 때 DB가 자체적으로 문자를 숫자로 변환하여 값을 비교하게 됩니다.  
위에서 일어난 내부적 변형을 외부적 변형으로 사용하게 된다면 아래와 같습니다.

```
// 비교 예제 외부적 변형
SELECT *
    FROM 예제테이블
WHERE CAST(문자 , SIGNED) // CAST() 는 MYSQL에서 사용하는 타입 변환 함수입니다. SIGNED는 부호가 있는 INTEGER 타입 입니다.
```

인덱스 사용의 핵심은 외부적,내부적으로 조건을 비교하기 전에 컬럼의 값이 변경이 된다면 사용할 수 없다라는 것을 기억하면 됩니다.

#### 추가 : 참고로 컬럼의 값이 NULL 이라면 처리대상에서 제외되므로 사전에 NULL 값을 제외 후 조건을 비교하지 않아도 됩니다.

## 부정형의 비교

-   NOT 조건을 사용하였을 때는 인덱스가 사용되지 않습니다.
-   인덱스는 비교 상수값의 문자열(STRING)과 인덱스 컬럼의 스트링을 B-TREE 방식으로 비교하여 찾게되는데  
    주어진 값이 아닌 값을 검색하기에 비교할 대상이 없습니다.  
    그러므로 인덱스를 사용하기 위해서는 부정형을 긍정형으로 바꾸어 작성하는 방법이 있습니다.
```
	// 예시코드 (인덱스 사용 x)
	SELECT 찾을컬럼
		FROM 테이블1 t1
	LEFT OUTER JOIN (
		SELECT *
			FROM 테이블2 
	) t2 ON t1.아이디 != t2.아이디
	
	// 예시코드 (긍정형 표현으로 인덱스 사용 o )
	SELECT 찾을컬럼
		FROM 테이블1
	WHERE NOT EXISTS(
		SELECT 찾을컬럼
			FROM 테이블2
		WHERE 테이블1.아이디 = 테이블2.아이디
		)
```
- 위의 예시는 테이블1 의 컬럼 아이디와 테이블2의 컬럼 아이디 값이 다른 값들을 가져오는 쿼리입니다. 
	- 조인으로 작성된 쿼리는 != 부정형 사용으로 인덱스를 사용하지 않습니다.
	- NOT EXSITS 또한 NOT 을 포함하고 있기에 부정형이라고 생각할 수 있지만 실제 데이터를 비교하는 서브쿼리 내 WHERE 절에서 긍정형 조건을 사용하여 값들을 비교하였기에 인덱스를 사용할 수 있습니다.

## NULL 을 사용한 비교
- ### NULL 컬럼의 적용
	- 테이블 설계 시 기본값을 NULL 으로 지정하게 된다면 풀스캔을 하거나 다른 조건을 사용해야합니다. 
	```
		// 예시 1 (주문날짜가 NULL 이 아닌 값들을 불러와 주문날짜순 정렬)
		SELECT 주문번호 , 주문날짜 , 주문아이템, 주문수량
			FROM 주문테이블
		WHERE 주문날짜 is NOT NULL
		ORDER BY 주문날짜
		
		// 예시 2 (주문날짜가 '' 이상만 검색)
		SELECT 주문번호 , 주문날짜 , 주문아이템, 주문수량
			FROM 주문테이블
		WHERE 주문날짜 > ''
	```
	- 위의 예시에서 NULL 을 직접적으로 비교 조건으로 사용하기보다는 문자열 비교를 통한 방법으로 변경하여 사용하였습니다.
- 그룹 함수 사용시 인덱스 사용 재고
	- SUM , COUNT , MAX , MIN , AVG 등의 그룹함수 
	- GROUP BY , ORDER BY , UNION , MINUS , INTERSECT 등
	- 위의 명령을 처리하게되면 전체범위 인덱스를 경유함으로써 인덱스 사용시 성능이 낮아질 수 있습니다.

- ### NULL 값 대체 방법
	- 컬럼 기본 값 NULL 대신 '' , 또는 0 등의 '빈 값' 지정합니다

## 분포도에 따른 인덱스 전략
- 아래와 같은 분포도가 있을 때 NULL 값을 활용하여 성능 개선하기
```
	A : 4%;
	B : 6%;
	C : 5%;
	D : 5%;
	E : 80%;
```
- E의 값을 NULL 으로 바꾸어 인덱스 미사용하기
	- NULL 값은 스캔 시 인덱스에 포함되지 않기 때문에 성능이 향상됩니다.

## 옵티마이저 취사선택
- 취사선택
	- `취할 것은 취하고 버릴 것은 버려서 골라 잡는 것을 말한다` 라는 뜻입니다.
-순위에 따른 취사선택
	- 각 컬림이 별도의 인덱스로 생성되어 있다면 인덱스 병합이 일어나지만 조건이 `LIKE` , `BETWEEN` , `<` , `>` 등이 같이 사용되었다면 둘중 하나를 포기합니다.
	
	```
		// 다른 인덱스 사용
		SELECT 가격 , 수량
			FROM 아이템
		WHERE 가격 >= 5000
			AND 수량 >= 100
			
		// 같은 인덱스 사용
		SELECT 가격 , 수량
			FROM 아이템
		WHERE 이름 LIKE '국내산%'
			AND 이름 LIKE '수입산%'
	```
	
- 낮은 처리 비용 선택
	- 옵티마이저는 항상 최저 비용을 엑세스하므로 통계 정보에 따라 사용되는 경우가 다양합니다.
	- 옵티마이저의 목표가 `FIRST_ROWS` 냐 `ALL_ROWS` 냐에 따라 비용 계산 방법이 달라집니다.
	- `FIRST_ROWS` 는 인덱스를 사용하지만 `ALL_ROWS`는 전체 테이블을 스캔합니다.
- 힌트에 의한 선택
	- 기존의 옵티마이저에 정의 되어 있는 인덱스 순위 대신 사용자가 인덱스 순위를 직접 기술하여 사용하는 것을 얘기합니다.
	- 사용 방법은 아래와 같습니다
	```
		// 힌트 사용 방법 : /*+ 힌트() */
		SELECT /*+ INDEX(등록일 인덱스) */ 이름 , 등록일
			FROM 아이템
		WHERE 이름 LIKE `국내산%` 
			AND 등록일 BETWEEN '221123' AND '221224'
	```
	- 위와 같은 SQL 에서는 항상 등록일 인덱스를 사용합니다.
 -힌트 기능 예시
	 - RULE : RULE BASE 옵티마이저를 사용합니다.
	 - FIRST_ROWS : 첫째 레코드의 추출 시간을 최소화 할 목적으로 최적화합니다.
	 - ALL_ROWS : 모든 레코드를 모두 처리하는 시간의 최소화를 목적으로 최적화합니다. 
	 - FULL : 지정된 테이블에 대한 전체스캔
	 - ROWID : 지정된 테이블에 대한 ROWID 에 의한 테이블 스캔
	 - CLUSTER : 지정된 테이블에 대한 클러스터 스캔
	 - HASH : 지정된 테이블에 대한 해시 스캔
	 - INDEX_ASC : 내림차순으로 인덱스를 스캔
	 - INDEX_DESC : 오름차순으로 인덱스를 스캔
	 - AND_EQUALS : 여러개의 인덱스를 병합하여 사용합니다 (2~5개)
	 - ORDERD : FROM 절에 기술된 테이블 순으로 JOIN 합니다.
	 - USE_NL : 먼저 특정 테이블의 ROW 를 엑세스하고 그값에 해당하는 다른 각각의 테이블의 ROW를 찾는 작업을 해당범위까지 실행하는 조인 먼저 각 테이블의 처리범위를 스캔하여 정렬 후 서로 병합하는 조인 방식입니다.
	 - USE_MERGE : 각 테이블의 처리범위를 스캔하여 정렬 후 서로 병합하며 조인합니다.
	 - PARALLEL : 병렬 처리 프로세서의 개수를 지정합니다.
	 - CACHE : 테이블의 로우들을 메모리 내 상주시킵니다.
	 - NOCACHE : 메모리 내 상주 시킨 옵션 해제
	 - MERGE-AJ : 부정형 조인 (안티조인) 을 병합정렬 방식으로 수행합니다.
	 - HASH-AJ : 부정형 조인을 해시 조인 방식으로 수행합니다.
	- 위의 예시들은 오라클 기준의 힌트들이며 사용 DB 힌트들을 참고하여 사용하시면 됩니다.

## 인덱스의 선정
- 인덱스는 실측 자료를 토대로 엑세스의 빈도 , 처리범위의 크기 , 분포도 , 테이블의 크기 , 엑세스 유형등을 종합적으로 검토하여 설정해야합니다.
- 인덱스 대상 테이블 선정
	- 테이블 크기가 작다면 DB가 멀티블럭 I/O 를 수행하기 때문에 성능 차이가 거의 없다.
	- 조인 연결고리가 되는 컬럼의 인덱스가 없을 때는 조인의 방향이 달라질 수 있으며 참조무결성을 지정한 경우 테이블 단위의 LOCK이 발생되므로 조인 연결 컬럼은 인덱스를 생성시키는 것이 좋습니다.
	- 보관용 테이블 , 풀스캔용 테이블 들은 당연히 인덱스를 사용할 필요가 없습니다.
- 분포도와 손익분기점
	- 인덱스를 생성시키려는 컬럼의 `분포도`는 `10~15%` 사이여야 하며 `분포도`란 컬럼이 테이블에 평균적으로 분포되어 있는 정도를 얘기합니다.
	```
	// 분포도 예시
		분포도 = 데이터별 평균 로우수 / 테이블 총 로우수 * 100 = 1 / 컬럼값의 종류 * 100
	```
	- 예를 들면 5개 지점을 가진 회사의 `지점` 컬럼은 값의 종류가 5가지이므로 분포도가 (1/5) * 100 = 20% 가 됩니다. 만약 어떤 테이블의 데이터가 100개를 가지고 있고 GROUP BY 수행 시 평균 10이라고 가정했을 때 (10/100) * 100 = 10% 가 됩니다.
- 인덱스 병합 (Merge)
	- 예시 SQL
	```
		SELECT *
			FROM 테이블
		WHERE 컬럼1 = 'ABC'
			AND 컬럼2 = '123';
	```
	- 위와 같은 SQL을 실행하는 엑세스 경로는 컬럼1 , 컬럼2 인덱스를 병합하여 수행한다고 가정합니다
	- 수행방법은 아래와 같습니다
		1. B-Tree 방법으로 컬럼1 인덱스에서 값이 'ABC'인 첫번째 로우와 컬럼2 인덱스에서 값이 '123' 인 첫번째 로우를 찾습니다. 
		2. 두개의 로우에 있는 ROW ID 를 비교하여 적은 값을 가진쪽 부터 차례대로 스캔하고 ROW ID 값이 같아지면 테이블의 로우를 엑세스하고 ROW ID 가 더 커질 때까지 스캔 후 멈춥니다.
		3. 이후 다른 인덱스에서도 동일하게 반복 수행합니다.
		4. 위와 같은 반복 수행 도중 다음 로우 값이 조건값과 다르면 작업을 중단합니다.
	- 위의 경우에서 인덱스 병합을 통해 테이블 엑세스 양은 줄이게 되었으나 인덱스 간 병합 양이 늘었으므로 실제 수행양이 줄었는지에 대해서도 고려해보아야 합니다.
	- 인덱스 병합을 하지 않고 컬럼1의 인덱스만 사용하는 예시
		1. B-Tree 방법으로 컬럼1 인덱스에서 값이 'ABC'인 첫번째 로우를 찾습니다.
		2. 인덱스 로우에 있는 ROW_ID 정보를 이용하여 테이블 로우를 엑세스합니다.
		3. 테이블 로우에 있는 컬럼2의 값이 '123'인 값만 선택합니다.
		4. 컬럼1의 인덱스를 로우 값이 조건과 다를 때까지 반복 수행합니다.
	- 정리
		- 인덱스 병합의 경우 서로 다른 몇개의 인덱스를 같은 ROW ID으로 병합하여야 하므로 실제 일한 양과 머지에 성공한 양에는 차이가 발생할 수 있습니다.
		
- 결합 인덱스 
	- 결합 인덱스를 쓰는 이유
		- where 조건에서 and 조건으로 자주 결합되어 사용되면서
		각각의 분포도 보다 두개 이상의 컬럼이 결합될 때 분포도가 좋아지는 컬럼들
		- 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼들
		- order by 에서 자주 사용되는 컬럼들
		- 하나 이상의 키 컬럼 조건으로 같은테이블의 컬럼들이 자주 조회될 때
	- 결합 인덱스 테이블 고려해야 할 우선순위
		- 조건절에서 인덱스의 첫번째 컬럼을 사용하지 않으면 인덱스는 사용되지 않습니다.
		- where절 조건에서 많이 사용되는 컬럼 우선시
		- Eqaul ('=') 으로 사용되는 컬럼 우선
		- 분포도가 좋은 컬럼을 우선
		- 자주 이용되는 순서대로 결합 인덱스 컬럼의 순서 결정

	<br/>

	- 예시 ( 컬럼1 + 컬럼2 인덱스가 있다고 가정)

	```
		SELECT *
			FROM 테이블
		WHERE 컬럼1 = 'A'
			AND 컬럼2 = '115'
	```
	- 예시 설명
		```

		- 예시 1 ( 작업 순서 컬럼1 - 분포도 넓음 , 컬럼2 - 분포도 좁음 )
			1. B-Tree 방식으로 컬럼1 = 'A' 이고 컬럼2 = '115' 인 첫번째 로우를 찾습니다.
			2. ROW ID 를 이용하여 테이블 로우를 엑세스합니다.
			3. 다음 로우를 차례대로 스캔하며 조건을 비교하여 조건 만족 시 테이블 로우를 엑세스 하고 아닐 시 작업을 종료합니다.
		- 예시 2 ( 작업 순서 컬럼2 - 분포도 좁음 , 컬럼1 - 분포도 넓음 )
			1. B-Tree 방식으로 컬럼2 = '115' 이고 컬럼1 = 'A' 인 첫번째 로우를 찾습니다.
			2. ROW ID 를 이용하여 테이블 로우를 엑세스합니다.
			3. 다음 로우를 차례대로 스캔하며 조건을 비교하여 조건 만족 시 
			테이블 로우를 엑세스 하고 아닐 시 작업을 종료합니다.
		```
	- 위의 두가지 예시는 같은 조건을 사용하지만 쿼리 수행 방법이 다릅니다.
		- 두 조건 모두 eqaul ('=') 을 사용한 경우에는 수행량 차이가 없습니다.
		- 분포도 보다 중요한 요소는 eqaul ('=') 조건이 먼저 사용될 것인지 입니다.
		- `LIKE` , `BETWEEN` , `>` , `<` 등과 같은 조건이 사용될 시에는 수행속도에 영향을 줍니다.
		- 결합 인덱스에서는 앞선 컬럼이 eqaul ('=') 으로 사용되지 않으면 그 뒤 
		컬럼을 eqaul ('=') 으로 사용했더라도 처리할 범위가 줄어들지 않습니다.
	
	<BR/>

	- 예시 SQL
	```
		SELECT * FROM 테이블 WHERE 컬럼1 = 'A' WHERE 컬럼2 BETWEEN '113' AND '115'
	```
	- SQL 작업 설명
	```
		예시 1 ( 분포도가 좁은 컬럼1이 앞에 위치하고 컬럼2가 결합 인덱스로 생성되어 있는 경우 )

		1. B-Tree 방식으로 컬럼1 = 'A' 이고 컬럼2 = '111' 인 첫번째 로우를 찾습니다.
		2. ROW ID 를 이용하여 테이블의 로우를 엑세스합니다.
		3. 다음 로우를 차례대로 스캔하면서 컬럼1이 'A' 가 아니거나 컬럼2가 '113'보다 클떄까지 테이블 로우를 엑세스하고 그렇지 않으면 작업을 종료합니다.

		예시 2 (컬럼1이 '='로 사용된 경우)
		
		1. B-Tree 방식으로 컬럼2 = '111' 이고 컬럼1 = 'A' 인 첫번째 로우를 찾습니다.
		2. ROW ID 를 이용하여 테이블 로우를 엑세스합니다.
		3. 다음 로우를 차례대로 스캔하면서 조건을 만족할 때까지 계속합니다.
		4. 조건을 만족하면 테이블의 로우를 엑세스합니다.
		5. 다음 로우를 계속 스캔하면서 3~4 를 반복합니다.
		6. 컬럼2의 조건을 더 이상 만족하지 않으면 작업을 종료합니다.
	```
	- 예시 1
		- 인덱스의 첫번째 컬럼이 '=' 으로 사용되었으므로 컬럼2가 '111'과
		'113' 사이에 있는 로우만 엑세스할 수 있습니다.
		- 컬럼1으로 정렬된 후 다시 컬럼2가 정렬되어 있으므로 컬럼1이 '=' 으로 사용된 범위 내엔 컬럼2가 차례대로 정렬되어 있으므로 '113' 뒤에는 '113' 보다 적은 값이 없기 때문입니다.
		- 그러므로 '113' 이상의 값을 만날 때 작업을 종료합니다.
	- 예시 2
		- 인덱스의 첫번째 컬럼이 '=' 으로 사용되지 않았을 때 뒤에 있는 컬럼을 '=' 으로 사용했다고 하더라도 처리범위는 줄어들지 않습니다.
		- '=' 조건은 단지 테이블을 엑세스 할 것인지에 대한 판단만 수행합니다.
		- 컬럼2 가 문자 타입이기 때문에 `111A` 가 있을 수 있으며 숫자 타입이라면
		`111.01` 도 있을 수 있습니다.
		- 상기 이유 때문에 컬럼 `111` 과 `113` 사이의 값을 모두 확인해보아야 합니다. ( 이러한 문제도 해결방법이 있다고 합니다. - 뒤에서 학습 -)

	- 정리 
		- BETWEEN 조건을 IN 절으로 대체하여 사용 
		- IN 절은 
			Where 컬럼1 = '조건' OR 컬럼2 = '조건' 과 같이 쓰입니다.
		- 분포도가 좋은 인덱스의 조건이 '=' 으로 사용되어 데이터를 읽어들입니다.
		- 인덱스 생성이 (컬럼1,컬럼2,컬럼3) 으로 되어 있을 때 필요한 조건이 2가지라고 하더라도 3가지 조건을 '=' 으로 주었을 때 인덱스를 사용하여 성능을 향상시킬 수 있습니다.

<br/>


- 결합 인덱스 컬럼 순서 결정 시 주의점
	- 결합 인덱스 사용 빈도
		- 결합 인덱스의 첫번째 컬럼을 조건에서 사용하지 않으면 인덱스는 사용되지 않습니다.
	- 항상 '=' 으로 사용되는지 여부
		- 앞선 조건의 컬럼이 '=' 으로 사용되지 않는다면 뒤에 있는 컬럼이 '=' 으로 사용되었더라도 처리 범위가 줄어들지 않습니다
	- 분포도가 좋은 컬럼을 우선
		- 분포도가 좋은 (좁은) 컬럼을 우선 사용하여야 처리범위를 보다 빠르게 줄일 수 있습니다.
		- 향후 `LIKE` , `BETWEEN` , `<` , `>` 과 같은 조건을 사용하여 처리 범위가 늘어난 경우 대비하기 유리합니다.
	- 자주 사용되는 정렬 순서
		- 인덱스의 컬럼 순서와 수행하고잫 ㅏ는 정렬 순서가 일치한다면 굳이 정렬 시키지 않고도 원하는 결과를 추출할 수 있습니다.
		- 부분범위처리를 이용하여 속도향상을 얻을 수 있습니다.
	- 상기 4가지 기준을 토대로 첫번째 컬럼을 선정합니다.

<br/>


- 결합인덱스의 컬럼순서 결정 방법
	- 항상 사용되는지 
	- 항상 '=' 으로 사용되는지
	- 분포도가 좋은 컬럼을 우선 
	- 자주 사용되는 정렬 순서 우선
	- 성능향상을 위한 추가 컬럼 탐색
	- 손익 분기점 이하의 컬럼 인덱스 생성
	- 부분범위처리 위해 손익분기점 이상의 분포도 컬럼 인덱스 생성
	
<br/>


- 인덱스 선정 절차
	- 해당 테이블의 가능한 모든 엑세스 형태 수집
		- 반복 수행되는 엑세스 형태 찾기
			- 반복수행되는 엑세스는 `자신의 수행속도 * 반복횟수` 만큼의 부하를 가집니다
			- 이러한 엑세스 유형을 찾기 위해 `다른 테이블`과 `조인` 시 연결고리가 되는 `기본키` 또는 `외부키`를 찾아 검토합니다
			- `서브쿼리`으로 적용되는 경우 `페치` 후 `루프` 내에서 반복 수행되는 경우를 예상해 연결고리 컬럼 찾아 검토합니다.
		- 분포도가 양호한 컬럼 발췌하여 엑세스 유형 조사
			- 하나의 컬럼만으로도 충분한 수행속도를 보장받을 수 있는 커럶 찾기
		- 자주 넓은 범위의 조건이 사용되는 경우 찾기
			- 부분범위 처리
				- 작업 수행중 추출할 로우수가 운반 단위에 도달하면 수행을 멈춥니다.
				# 계속 쓰기
		- 조건에 자주 사용되는 주요 컬럼 추출하여 엑세스 유형 조사
		- 자주 결합되어 사용되는 컬럼들의 조합 형태 및 정렬 순서 조사
		- 역순으로 정렬하여 추출되는 경우 조사
		- 일련번호 부여하는 경우 조사
		- 통계자료 추출을 위한 엑세스 유형 조사
	- 대상 컬럼 선정 및 분포도 조사
	- 반복 수행되는 엑세스 경로 해결
	- 클러스터링 검토
	- 인덱스 컬럼의 조합 및 순서 결정
	- 시험 생성 및 테스트
	- 수정 / 적용

<br/>

---
# 조인

## 조인 최적화
- 가장 효율적인 논리적 조인 경로는 이미 정해져 있습니다.
- 최적의 경로를 찾을 수 있도록 인덱스,클러스터 등의 옵티마이징 펙터를 지정해주어야 합니다.

## 조인 순서
- 조인 순서
- 조인은 각 집합의 처리범위와 순서에 따라 영향을 받습니다.
- 좁은 범위부터 처리할 경우 효율이 증가합니다.
- 하지만 모든 조인이 순서에 영향을 받는것은 아닙니다.

## 조인 유형 
- 중첩 루프 조인 ( Nested Loop Join )
	- 수행속도
		- 조인의 순서에 따라 수행속도 차이가 많이 납니다.
	- 조인 성공률
		- 조인 성공률이란?
			- 조인 조건을 만족하는 총 로우 (성공 로우) 수
			- 즉 조인 성공률이 낮을수록 이후 처리범위가 줄어듭니다.
	- 연결고리 상태
		- 정상
			- 테이블 간 값들이 모두 존재하고 인덱스가 있을 때
				- 처리범위를 줄여나가며 성능 향상
		- 이상 
			- 어느 한쪽의 연결고리에 인덱스(혹은 클러스터)가 없을 때
				- 테이블1의 값이 테이블2에 존재하지 않을 떄
				테이블1의 로우 수만큼 테이블2를 풀스캔하는 최악의 경우가 발생합니다.
				- 해당 경우 인덱스가 없는 테이블에서
				인덱스가 있는 테이블으로 엑세스할 수 있도록 설계해야합니다.
			- 이상 상태들
				- 조인되는 컬럼이 1대1으로 대응되지 않는 경우
				- 데이터 타입 차이에 의해 발생되는 경우
		
- 병합 정렬 조인 ( Sort Merge Join )
	- 연결고리 인덱스 사용 x
	- 연결고리에 영향을 받지 않습니다.
	- 양쪽 연결고리 이상 시 병합 정렬 조인

<br/>

## 조인의 튜닝
- 

<br/>



# 참고 자료
- 대용량 데이터베이스 솔루션 I 

---
## 참고 예정
- 대용량 데이터베이스 솔루션 II
- Real MySQL 8.0 1권
- Real MySQL 8.0 2권