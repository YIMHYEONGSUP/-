## 인덱스의 활용

### 인덱스란?

-   인덱스는 Key의 기능만 수행하는 것이 아닌 옵티마이저가 최적의 처리 경로를 결정하기 위한 요소(Factor)이다.
-   인덱스는 아래의 코드로 생성할 수 있다.인덱스의 구조
    -   CREATE \[유니크\] INDEX \[스키마 명\]인덱스명 ON \[스키마명\].테이블명 (컬럼들)  
        대괄호\[\] 항목은 생략 가능합니다.
-   DB 에 저장 되어 있는 데이터는 \[ INDEX-KEY \] , \[ ROW-ID \] 으로 구성되어 있습니다.
-   과도한 인덱스 생성은 SELECT는 빠를 수 있지만 데이터 변경 (INSERT , UPDATE , DELETE ) 시에 느려질 수 있습니다.
-   인덱스 적용 원칙
    -   인덱스 컬럼은 비교되기 전 변형이 일어나면 인덱스를 사용할 수 없습니다.
    -   인덱스 컬럼은 외부적,내부적 변형 둘 다 가능합니다.
    -   부정형 (Not , <>) 조건 시에도 인덱스를 사용하지 않습니다.
    -   인덱스 컬럼은 비교 상수값과 B-Tree 방식으로 문자열(String) 값을 비교하여 찾습니다.
        -   위와 같은 이유로 인해 비교값이 없는 부정형은 인덱스를 사용할 수 있는 방법이 없습니다.
        -   부정형 조건을 긍정형 조건으로 변경하여 인덱스를 사용하는 방법을 권장합니다.
-   인덱스 컬럼의 값이 NULL 이라면 당연히 인덱스 사용이 불가능합니다.
    -   복합적으로 결합된 인덱스 컬럼일 경우 첫번째 컬럼이 아닌 값을 NULL으로 비교할 시에는 인덱스가 사용됩니다.
-   옵티마이저가 필요에 따라 상기 적용원칙을 준수하였음에도 불구하고 특정 인덱스의 사용을 취사 선택함으로 사용되지 않는 인덱스가 생길 수 있습니다.
    -   인덱스의 머지 ( Merge ) 피하기 위해서,
    -   조건의 순위에 차이가 있을 때 취사 선택, 사용자힌트 , 통계정보 등에 의거하여 산출된 엑세스 비용의 차이에 따라 결정될 수 있습니다.

## 외부적 변형

-   함수, 연산자 등에 의해 컬럼에 변형을 가하는 행위
-   SQL함수, 사용자 지정함수 , 연산 , 결합 등으로 가공 시킨 후 비교할 때 발생됩니다.

```
// 예시  

// 인덱스 미사용
SELECT 컬럼1 , 컬럼2 , 컬럼3
    FROM 테이블
WHERE 함수( 컬럼 , 조건 ) = '해당조건'

// 인덱스 사용
SELECT 컬럼1 , 컬럼2 , 컬럼3
    FROM 테이블
WHERE 조건 LIKE '찾을문자열'%
```

외부 함수를 써서 컬럼의 값을 변경 후 조건과 일치하는지 비교하기 때문에 기존의 인덱스를 활용할 수 없습니다.  
하지만 예시로 작성된 LIKE 조건인 경우 기존의 컬럼을 변경하지 않고 조건을 찾기 때문에 인덱스를 활용할 수 있습니다.  
  

#### 정리 : 컬럼의 값을 변경한 후 조건을 찾게 되면 인덱스를 사용할 수 없다.

## 내부적 변형

-   사용자가 의도하여 외부적 변형을 하지 않았음에도 불구하고 서로 다른 데이터 타입을 비교하고자 할 때 DBMS 자체적으로 컬럼의 값을 변경하여 조건을 비교하는 것을 내부적 변형이라고 합니다.
-   변형 기준 참고 (link 넣어야함)// 테이블 생성  
    CREATE TABLE 예제테이블 (
-   `문자, CHAR(10), 숫자, NUMBER(12 , 3), 동적문자, VARCHAR(20), 날짜, DATE )`
-   // 예시

만약 위의 테이블에서 문자 컬럼과 숫자 컬럼을 아래와 같이 비교하려고 합니다,

```
// 비교 예제
SELECT *
    FROM 예제테이블
WHERE 문자 = 10
```

문자 컬럼의 값이 10일 때 라는 조건이 주어졌습니다.  
이 때 DB가 자체적으로 문자를 숫자로 변환하여 값을 비교하게 됩니다.  
위에서 일어난 내부적 변형을 외부적 변형으로 사용하게 된다면 아래와 같습니다.

```
// 비교 예제 외부적 변형
SELECT *
    FROM 예제테이블
WHERE CAST(문자 , SIGNED) // CAST() 는 MYSQL에서 사용하는 타입 변환 함수입니다. SIGNED는 부호가 있는 INTEGER 타입 입니다.
```

인덱스 사용의 핵심은 외부적,내부적으로 조건을 비교하기 전에 컬럼의 값이 변경이 된다면 사용할 수 없다라는 것을 기억하면 됩니다.

#### 추가 : 참고로 컬럼의 값이 NULL 이라면 처리대상에서 제외되므로 사전에 NULL 값을 제외 후 조건을 비교하지 않아도 됩니다.

## 부정형의 비교

-   NOT 조건을 사용하였을 때는 인덱스가 사용되지 않습니다.
-   인덱스는 비교 상수값의 문자열(STRING)과 인덱스 컬럼의 스트링을 B-TREE 방식으로 비교하여 찾게되는데  
    주어진 값이 아닌 값을 검색하기에 비교할 대상이 없습니다.  
    그러므로 인덱스를 사용하기 위해서는 부정형을 긍정형으로 바꾸어 작성하는 방법이 있습니다.
```
	// 예시코드 (인덱스 사용 x)
	SELECT 찾을컬럼
		FROM 테이블1 t1
	LEFT OUTER JOIN (
		SELECT *
			FROM 테이블2 
	) t2 ON t1.아이디 != t2.아이디
	
	// 예시코드 (긍정형 표현으로 인덱스 사용 o )
	SELECT 찾을컬럼
		FROM 테이블1
	WHERE NOT EXISTS(
		SELECT 찾을컬럼
			FROM 테이블2
		WHERE 테이블1.아이디 = 테이블2.아이디
		)
```
- 위의 예시는 테이블1 의 컬럼 아이디와 테이블2의 컬럼 아이디 값이 다른 값들을 가져오는 쿼리입니다. 
	- 조인으로 작성된 쿼리는 != 부정형 사용으로 인덱스를 사용하지 않습니다.
	- NOT EXSITS 또한 NOT 을 포함하고 있기에 부정형이라고 생각할 수 있지만 실제 데이터를 비교하는 서브쿼리 내 WHERE 절에서 긍정형 조건을 사용하여 값들을 비교하였기에 인덱스를 사용할 수 있습니다.

## NULL 을 사용한 비교
- ### NULL 컬럼의 적용
	- 테이블 설계 시 기본값을 NULL 으로 지정하게 된다면 풀스캔을 하거나 다른 조건을 사용해야합니다. 
	```
		// 예시 1 (주문날짜가 NULL 이 아닌 값들을 불러와 주문날짜순 정렬)
		SELECT 주문번호 , 주문날짜 , 주문아이템, 주문수량
			FROM 주문테이블
		WHERE 주문날짜 is NOT NULL
		ORDER BY 주문날짜
		
		// 예시 2 (주문날짜가 '' 이상만 검색)
		SELECT 주문번호 , 주문날짜 , 주문아이템, 주문수량
			FROM 주문테이블
		WHERE 주문날짜 > ''
	```
	- 위의 예시에서 NULL 을 직접적으로 비교 조건으로 사용하기보다는 문자열 비교를 통한 방법으로 변경하여 사용하였습니다.
- 그룹 함수 사용시 인덱스 사용 재고
	- SUM , COUNT , MAX , MIN , AVG 등의 그룹함수 
	- GROUP BY , ORDER BY , UNION , MINUS , INTERSECT 등
	- 위의 명령을 처리하게되면 전체범위 인덱스를 경유함으로써 인덱스 사용시 성능이 낮아질 수 있습니다.

- ### NULL 값 대체 방법
	- 컬럼 기본 값 NULL 대신 '' , 또는 0 등의 '빈 값' 지정합니다

## 분포도에 따른 인덱스 전략
- 아래와 같은 분포도가 있을 때 NULL 값을 활용하여 성능 개선하기
```
	A : 4%;
	B : 6%;
	C : 5%;
	D : 5%;
	E : 80%;
```
- E의 값을 NULL 으로 바꾸어 인덱스 미사용하기
	- NULL 값은 스캔 시 인덱스에 포함되지 않기 때문에 성능이 향상됩니다.

## 옵티마이저 취사선택
- 취사선택
	- `취할 것은 취하고 버릴 것은 버려서 골라 잡는 것을 말한다` 라는 뜻입니다.
-순위에 따른 취사선택
	- 각 컬림이 별도의 인덱스로 생성되어 있다면 인덱스 병합이 일어나지만 조건이 `LIKE` , `BETWEEN` , `<` , `>` 등이 같이 사용되었다면 둘중 하나를 포기합니다.
	
	```
		// 다른 인덱스 사용
		SELECT 가격 , 수량
			FROM 아이템
		WHERE 가격 >= 5000
			AND 수량 >= 100
			
		// 같은 인덱스 사용
		SELECT 가격 , 수량
			FROM 아이템
		WHERE 이름 LIKE '국내산%'
			AND 이름 LIKE '수입산%'
	```
	
- 낮은 처리 비용 선택
	- 옵티마이저는 항상 최저 비용을 엑세스하므로 통계 정보에 따라 사용되는 경우가 다양합니다.
	- 옵티마이저의 목표가 `FIRST_ROWS` 냐 `ALL_ROWS` 냐에 따라 비용 계산 방법이 달라집니다.
	- `FIRST_ROWS` 는 인덱스를 사용하지만 `ALL_ROWS`는 전체 테이블을 스캔합니다.
- 힌트에 의한 선택
	- 기존의 옵티마이저에 정의 되어 있는 인덱스 순위 대신 사용자가 인덱스 순위를 직접 기술하여 사용하는 것을 얘기합니다.
	- 사용 방법은 아래와 같습니다
	```
		// 힌트 사용 방법 : /*+ 힌트() */
		SELECT /*+ INDEX(등록일 인덱스) */ 이름 , 등록일
			FROM 아이템
		WHERE 이름 LIKE `국내산%` 
			AND 등록일 BETWEEN '221123' AND '221224'
	```
	- 위와 같은 SQL 에서는 항상 등록일 인덱스를 사용합니다.
 -힌트 기능 예시
	 - RULE : RULE BASE 옵티마이저를 사용합니다.
	 - FIRST_ROWS : 첫째 레코드의 추출 시간을 최소화 할 목적으로 최적화합니다.
	 - ALL_ROWS : 모든 레코드를 모두 처리하는 시간의 최소화를 목적으로 최적화합니다. 
	 - FULL : 지정된 테이블에 대한 전체스캔
	 - ROWID : 지정된 테이블에 대한 ROWID 에 의한 테이블 스캔
	 - CLUSTER : 지정된 테이블에 대한 클러스터 스캔
	 - HASH : 지정된 테이블에 대한 해시 스캔
	 - INDEX_ASC : 내림차순으로 인덱스를 스캔
	 - INDEX_DESC : 오름차순으로 인덱스를 스캔
	 - AND_EQUALS : 여러개의 인덱스를 병합하여 사용합니다 (2~5개)
	 - ORDERD : FROM 절에 기술된 테이블 순으로 JOIN 합니다.
	 - USE_NL : 먼저 특정 테이블의 ROW 를 엑세스하고 그값에 해당하는 다른 각각의 테이블의 ROW를 찾는 작업을 해당범위까지 실행하는 조인 먼저 각 테이블의 처리범위를 스캔하여 정렬 후 서로 병합하는 조인 방식입니다.
	 - USE_MERGE : 각 테이블의 처리범위를 스캔하여 정렬 후 서로 병합하며 조인합니다.
	 - PARALLEL : 병렬 처리 프로세서의 개수를 지정합니다.
	 - CACHE : 테이블의 로우들을 메모리 내 상주시킵니다.
	 - NOCACHE : 메모리 내 상주 시킨 옵션 해제
	 - MERGE-AJ : 부정형 조인 (안티조인) 을 병합정렬 방식으로 수행합니다.
	 - HASH-AJ : 부정형 조인을 해시 조인 방식으로 수행합니다.
	- 위의 예시들은 오라클 기준의 힌트들이며 사용 DB 힌트들을 참고하여 사용하시면 됩니다.

## 인덱스의 선정
- 인덱스는 실측 자료를 토대로 엑세스의 빈도 , 처리범위의 크기 , 분포도 , 테이블의 크기 , 엑세스 유형등을 종합적으로 검토하여 설정해야합니다.
- 인덱스 대상 테이블 선정
	- 테이블 크기가 작다면 DB가 멀티블럭 I/O 를 수행하기 때문에 성능 차이가 거의 없다.
	- 조인 연결고리가 되는 컬럼의 인덱스가 없을 때는 조인의 방향이 달라질 수 있으며 참조무결성을 지정한 경우 테이블 단위의 LOCK이 발생되므로 조인 연결 컬럼은 인덱스를 생성시키는 것이 좋습니다.
	- 보관용 테이블 , 풀스캔용 테이블 들은 당연히 인덱스를 사용할 필요가 없습니다.
- 분포도와 손익분기점
	- 인덱스를 생성시키려는 컬럼의 `분포도`는 `10~15%` 사이여야 하며 `분포도`란 컬럼이 테이블에 평균적으로 분포되어 있는 정도를 얘기합니다.
	```
	// 분포도 예시
		분포도 = 데이터별 평균 로우수 / 테이블 총 로우수 * 100 = 1 / 컬럼값의 종류 * 100
	```
	- 예를 들면 5개 지점을 가진 회사의 `지점` 컬럼은 값의 종류가 5가지이므로 분포도가 (1/5) * 100 = 20% 가 됩니다. 만약 어떤 테이블의 데이터가 100개를 가지고 있고 GROUP BY 수행 시 평균 10이라고 가정했을 때 (10/100) * 100 = 10% 가 됩니다.
	- 


---
# 참고 자료
- 대용량 데이터베이스 솔루션 I 

---
## 참고 예정
- 대용량 데이터베이스 솔루션 II
- Real MySQL 8.0 1권
- Real MySQL 8.0 2권